/* ***** BEGIN LICENSE BLOCK *****
 * vim: set ts=4 sw=4 et tw=80:
 *
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Narcissus JavaScript engine.
 *
 * The Initial Developer of the Original Code is
 * Brendan Eich <brendan@mozilla.org>.
 * Portions created by the Initial Developer are Copyright (C) 2004
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/*
 * Narcissus - JS implemented in JS.
 *
 * Execution of parse trees.
 *
 * Standard classes except for eval, Function, Array, and String are borrowed
 * from the host JS environment.  Function is metacircular.  Array and String
 * are reflected via wrapping the corresponding native constructor and adding
 * an extra level of prototype-based delegation.
 */

const GLOBAL_CODE = 0, EVAL_CODE = 1, FUNCTION_CODE = 2;

// this global helps to match conditions within a paranthesis
// x == 9 && (t1 == 10 || t1 == 11 || t1 == 12)
// the three caluses in the last AND clause should be combined first
// t1 == 10 : true
// NOT(t1 == 10) AND t1 == 11 : true
// NOT(t1 == 10) AND NOT (t1 == 11) AND t1 == 12 : true
// NOT(t1 == 10) AND NOT (t1 == 11) AND NOT(t1 == 12): false
// and then combine these true/false with the AND conditions
var clauseCounter = 0;

function ExecutionContext(type) {
    p("execution context - " + type);
    this.type = type;
    this.programCondition = "true"; 
    this.nextInstruction =  null;
    this.notamper_index = null;
    this.calledExecutionContext_result = null;
    this.calledExecutionContext_programCondition = "";
}

var global = {
    // Value properties.
    NaN: NaN, Infinity: Infinity, undefined: undefined,

    // Function properties.
    eval: function eval(s) {
        if (typeof s != "string")
            return s;
        
        p(" Eval called : " + s);
        
        var x = ExecutionContext.current;
        var x2 = new ExecutionContext(EVAL_CODE);
        x2.thisObject = x.thisObject;
        x2.caller = x.caller;
        x2.callee = x.callee;
        x2.scope = x.scope;
        ExecutionContext.current = x2;
        try {
            execute(parse(s), x2);
        } catch (e if e == THROW) {
            x.result = x2.result;
            throw e;
        } finally {
            ExecutionContext.current = x;
        }
        return x2.result;
    },
    parseInt: parseInt, parseFloat: parseFloat,
    isNaN: isNaN, isFinite: isFinite,
    decodeURI: decodeURI, encodeURI: encodeURI,
    decodeURIComponent: decodeURIComponent,
    encodeURIComponent: encodeURIComponent,

    // Class constructors.  Where ECMA-262 requires C.length == 1, we declare
    // a dummy formal parameter.
    Object: Object,
    Function: function Function(dummy) {
        p(" Function : called : " + dummy);
            
        var p = "", b = "", n = arguments.length;
        if (n) {
            var m = n - 1;
            if (m) {
                p += arguments[0];
                for (var k = 1; k < m; k++)
                    p += "," + arguments[k];
            }
            b += arguments[m];
        }

        // XXX We want to pass a good file and line to the tokenizer.
        // Note the anonymous name to maintain parity with Spidermonkey.
        var t = new Tokenizer("anonymous(" + p + ") {" + b + "}");

        // NB: Use the STATEMENT_FORM constant since we don't want to push this
        // function onto the null compilation context.
        var f = FunctionDefinition(t, null, false, STATEMENT_FORM);
        var s = {object: global, parent: null};
        return new FunctionObject(f, s);
    },
    Array: function Array(dummy) {
    //  p(" Array Constructor : called : " + dummy);

        // Array when called as a function acts as a constructor.
        return GLOBAL.Array.apply(this, arguments);
    },
    String: function String(s) {
    //p(" String Constructor : called : " + s);
        // Called as function or constructor: convert argument to string type.
        s = arguments.length ? "" + s : "";
        if (this instanceof String) {
            // Called as constructor: save the argument as the string value
            // of this String object and return this object.
            this.value = s;
            return this;
        }
        return s;
    },
    Boolean: Boolean, Number: Number, Date: Date, RegExp: RegExp,
    Error: Error, EvalError: EvalError, RangeError: RangeError,
    ReferenceError: ReferenceError, SyntaxError: SyntaxError,
    TypeError: TypeError, URIError: URIError,

    // Other properties.
    Math: Math,

    // Extensions to ECMA.
    snarf: snarf, evaluate: evaluate,
    load: function load(s) {

        if (typeof s != "string")
            return s;
     //   p(" load called  : " + s);

        evaluate(snarf(s), s, 1)
    },
    print: print, version: null
};

// Helper to avoid Object.prototype.hasOwnProperty polluting scope objects.
function hasDirectProperty(o, p) {
    //print("hasDirectProperty"); 
    //p (" \t\t object - " + o + " property - " + p);
    return Object.prototype.hasOwnProperty.call(o, p);
}

// Reflect a host class into the target global environment by delegation.
function reflectClass(name, proto) {
    //p ( " reflect class "); 
    //p ("\t\t name - " + name + " proto - " + proto);
    
    var gctor = global[name];
    gctor.__defineProperty__('prototype', proto, true, true, true);
    proto.__defineProperty__('constructor', gctor, false, false, true);
    return proto;
}

// Reflect Array -- note that all Array methods are generic.
reflectClass('Array', new Array);

// Reflect String, overriding non-generic methods.
var gSp = reflectClass('String', new String);
gSp.toSource = function () { return this.value.toSource(); };
gSp.toString = function () { return this.value; };
gSp.valueOf  = function () { return this.value; };
global.String.fromCharCode = String.fromCharCode;

var XCp = ExecutionContext.prototype;
ExecutionContext.current = XCp.caller = XCp.callee = null;
XCp.scope = {object: global, parent: null};
XCp.thisObject = global;
XCp.result = undefined;
XCp.target = null;
XCp.ecmaStrictMode = false;

p ( " Execution context definition"); p ( " \t \t " + XCp);

function Reference(base, propertyName, node) {
    this.base = base;
    this.propertyName = propertyName;
    this.notamper_symbolic = false; 
    this.node = node;
    
//    p( " Reference () ");
//    p( " \t \t property - " + propertyName  + " node - " + node);
}

Reference.prototype.toString = function () { return this.node.getSource() + " Symbolic - " + this.notamper_symbolic; }

function notamper_getPropertyName(s)
{
    return s + "_notamper_symbolic";
}

function getValue(v) {

    var retValue = null;
    if (v instanceof Reference) {
        if (!v.base) {
            throw new ReferenceError(v.propertyName + " is not defined",
                                     v.node.filename, v.node.lineno);
        }
  //      p ("getValue: ");
//        p ( "\t\t return 1 - " + v.base[v.propertyName] + " property - " + v.propertyName  + " and symbolic - " + (v.base||global)[notamper_getPropertyName(v.propertyName)]);
        // return v.base[v.propertyName];
        retValue = v.base[v.propertyName];
    }
    else
    {
        retValue  = v; 
    }
    
    if ( retValue != null && (typeof retValue == "string") && 
        retValue.substring("_notamper_symbolic") != -1)
    {
        (v.base || global) [notamper_getPropertyName(v.propertyName)] = true;    
    }
    
    p (" getValue returns- " + retValue);
    return retValue;
}

function putValue(v, w, vn) {
        //p(" putValue");
        //p("checkout put value \t\t : " + v + " property name "+ v.propertyName + " w = " + w + " file - " + v.node.filename  + " line - " + v.node.lineno);

    if (v instanceof Reference)
    {
//        if(v.base != null)
//        {
//         for (var i = 0; i < v.base.length ; i++)
//            p (" \t \t - item " + i + " value - " + v.base[i]);
//        }

//        if( (typeof w) == "string" && w.substring("_notamper_symbolic") != -1)
//            (v.base || global) [notamper_getPropertyName(v.propertyName)] = true;
    
//        p ( " \t\t\t v.base = " + v.base + " global - " + global + 
//            " v.propertyName - " + v.propertyName + " w -  " + w +  " and type - " + w.type + 
//            " global[email1_notamper_symbolic] = " + 
//            (v.base || global)[notamper_getPropertyName(v.propertyName)]);
        return (v.base || global)[v.propertyName] = w;
    }
    throw new ReferenceError("Invalid assignment left-hand side",
                             vn.filename, vn.lineno);
}

function isPrimitive(v) {
    //p ( " isPrimitive \n \t\t " + v );
    var t = typeof v;
    return (t == "object") ? v === null : t != "function";
}

function isObject(v) {
    var t = typeof v;
    return (t == "object") ? v !== null : t == "function";
}

// If r instanceof Reference, v == getValue(r); else v === r.  If passed, rn
// is the node whose execute result was r.
function toObject(v, r, rn) {
    switch (typeof v) {
      case "boolean":
        return new global.Boolean(v);
      case "number":
        return new global.Number(v);
      case "string":
        return new global.String(v);
      case "function":
        return v;
      case "object":
        if (v !== null)
            return v;
    }
    var message = r + " (type " + (typeof v) + ") has no properties";
    throw rn ? new TypeError(message, rn.filename, rn.lineno)
             : new TypeError(message);
}

function getNodeType ( n )
{
    if ( n != null)
        return tokenstr ( n.type );
    else
        return "null";
} 

function setNextInstruction ( currentInstruction, nextInstruction )
{
    // as BLOCKs are recursively executed, setNextInstruction does not recuse
    // for all instructions if current stmt is a BLOCK itself. instead it traverses
    // to the last instruction in current block and recurses there. In turn when 
    // BLOCKs are visited recursively, setNextInstruction is only invoked for 
    // instructions apart from the last.  
    var ctype = currentInstruction.type;
    if ( ctype == BLOCK )
    {
        var lastInstruction = currentInstruction[currentInstruction.length - 1];
        setNextInstruction (lastInstruction, nextInstruction);
    }
    else if (ctype == IF)
    {
        // if condition guard is symbolically executed both then/else parts are
        // to be executed. it is recorded in the pendingExecutionContexts. 
        setNextInstruction (currentInstruction.thenPart, nextInstruction);
        if (currentInstruction.elsePart != null)
            setNextInstruction (currentInstruction.elsePart, nextInstruction)
    }
    else
    {
        // otherwise current instruction is a simple instruction
        currentInstruction.nextInstruction = nextInstruction;
    }
}

function updatePC(xc, pc)
{
    p ( " updatePC  - " + xc.programCondition + " pc = " + pc );
    if ( "" + xc.programCondition == "true")
    {
        xc.programCondition = "" + pc ; 
    }
    else
    {
        xc.programCondition += " AND " + pc ; 
    }
}

function die_with_message ( msg )
{
    // whats an elegant way to exit from a standalone js ? 
    var m = " FATAL MESSAGE : " + msg; 
    p ( m.toUpperCase () );
    throw new TypeError(m);
}


//            forkSymbolicExecution ( n[i] , n[i].initializer , x, n.nextInstruction, n.type);     

// lval = rval ; in execution context x
function forkSymbolicExecution ( lval, rval, x, nNext, nType)
{
    if ( nNext == null)
        p ( " forkSymbolicExecution called with null next instruction. " + 
            "\n \t  lval - " + lval + " rval - " + rval); 

    var u = rval;   
    if (!u)
        return;
        
    var t = lval;
    for (var s = x.scope; s; s = s.parent) {
        if (hasDirectProperty(s.object, t))
            break;
    }
    
    var u1 = getValue(execute(u, x));
    if ( u.type == CALL )
    {
        var xpr = x.calledExecutionContext_result;
        xpr = (xpr == null ? u1 : xpr);
        var xpc = x.calledExecutionContext_programCondition;
        //p ( " var initialization - " + t + " called ret = " + xpr +
        //    " pc = " + x.calledExecutionContext_programCondition);

        // if called function's program condition is not true, it executed 
        // symbolically. lval must receive values corresponding to all return
        // records of the called function. notamper stores all but one return 
        // record alongwith its execution context to execute later.   
        if ( xpc != "true" )
        {
            fn = u[0].value; 
       
            var actuals = [];     
            var args = u[1]; 
            if ( args.type == LIST )
            {
                p ( " \t arguments - " + args.length);
                for (i1 = 0, j1 = args.length; i1 < j1; i1++) 
                {
                    value = execute(args[i1], x);
                    a1 = getValue(value);
                    p ( " \t \t actual - " + a1);
                    actuals[i1] = a1;
                }
            }
            
            allReturnRecords = findReturnRecords( fn, ReturnRecords, actuals);
            //var rrlen = allReturnRecords.length;
            // printReturnRecords ( allReturnRecords );
            var itmp = 0; 
            var count = allReturnRecords.getCount();
            for ( itmp = 0; itmp < count ; itmp++)
            {
                var mem = allReturnRecords.getAt( itmp );
//                p ( "  record #" + mem.index + " \t funcName : " + 
//                    mem.funcName + " \t returns = |" + mem.retValue + 
//                    "| \t pc = |" + mem.pc + "|" + " typeof return - " + (typeof mem.retValue) + " typeof pc - " + (typeof mem.pc));
//                p ( " matching against - returns = |" + xpr + "|\t pc - |" + xpc + "|" + " typeof ret - " + 
//                    (typeof xpr) + " typeof pc - " + (typeof xpc));

                // convert all objects to string type for comparison                    
                if ( (("" + mem.pc) == ("" + xpc)) && (("" + xpr) == ("" + mem.retValue)))
                {
//                            p ( " skipping: " + " record#" + mem.index + " fn - " + 
//                                mem.funcName + " ret - " + mem.retValue + " pc - " + mem.pc);
//                            if (n.type == CONST)
//                                s.object.__defineProperty__(t, xpr, x.type != EVAL_CODE, true);
//                            else
//                                s.object[t] = xpr;
//                            x.programCondition += " AND " + mem.pc; 
                }
                else
                {
                    p ( " next instruction to execute - " + nNext);
                    if (nType == CONST)
                        s.object.__defineProperty__(t, mem.retValue, x.type != EVAL_CODE, true);
                    else
                        s.object[t] = mem.retValue;
                    xcSaved = cloneObject ( x );
                    updatePC(xcSaved, mem.pc);
                    xcSaved.nextInstruction = nNext;
                    
                    xcSaved.notamper_index = RRIndex++;
                    p ( " adding a pending execution after var init " + t + " notamper_index - " + 
                        xcSaved.notamper_index + " return value - " + mem.retValue + " next - " + nNext); 
                    PendingExecutions.add( xcSaved );
                    printPendingExecutions( PendingExecutions ); 
                    p ( " reset the local var - " + xpr);
                    if (nType == CONST)
                        s.object.__defineProperty__(t, xpr, x.type != EVAL_CODE, true);
                    else
                        s.object[t] = xpr;    
                
                }    
            }
            for ( itmp = 0; itmp < count ; itmp++)
            {
                var mem = allReturnRecords.getAt( itmp );
                if ( (("" + mem.pc) == ("" + xpc)) && (("" + xpr) == ("" + mem.retValue)))
                {
                    p ( " skipping: " + " record#" + mem.index + " fn - " + 
                        mem.funcName + " ret - " + mem.retValue + " pc - " + mem.pc);
                    if (nType == CONST)
                        s.object.__defineProperty__(t, xpr, x.type != EVAL_CODE, true);
                    else
                        s.object[t] = xpr;
                        
                    updatePC(x, mem.pc);   
                }
            }

        }
    }
//    p ( " here : s - " + s + " t - " + t + " u1 = " + u1);
    if (nType == CONST)
        s.object.__defineProperty__(t, u1, x.type != EVAL_CODE, true);
    else
        s.object[t] = u1;
        
    return u1;
}


function executeBinaryOperator(n, x)
{
    var v1 = getValue(execute(n[0], x));
    var v2 = getValue(execute(n[1], x));
    if (isSymbolic(v1) || isSymbolic(v2))
    {
        var v1Quotes = (n[0].type == STRING) ? "\"" : "";
        var v2Quotes = (n[1].type == STRING) ? "\"" : "";        
        
        var trueCondition = v1Quotes + v1 + v1Quotes;
        var tmp = v2Quotes + v2 + v2Quotes;

        // symbolic execution 
        switch (n.type)
        {
            case NE: trueCondition += " != " + v2; break; 
            case EQ: trueCondition += " == " + v2; break;
            case STRICT_EQ: trueCondition += " == " + v2; break;           
            case STRICT_NE: trueCondition += " != " + v2; break;
            case LT: trueCondition += " < " + v2; break;
            case LE: trueCondition += " <= " + v2; break;
            case GE: trueCondition += " >= " + v2; break;
            case GT: trueCondition += " > " + v2; break;
            case PLUS: trueCondition += " + " + v2; break;
            case MINUS: trueCondition += " - " + v2; break;
            case MUL: trueCondition += " * " + v2; break;
            case DIV: trueCondition += " / " + v2; break;
            case MOD: trueCondition += " % " + v2; break;

            default : 
            die_with_message ("unhandled symbolic execution of binary operator - n[0] " + 
                n[0] + " n[1] - " + n[1]);
        }       
        
        if (n.type != PLUS || n.type != MINUS || n.type != MUL ||
            n.type != DIV || n.type != MOD)
        {
            var falseCondition = " NOT ( " + trueCondition + " ) ";
            conditionCases.add(new ConditionRecord(conditionIndex++, true, trueCondition));
            conditionCases.add(new ConditionRecord(conditionIndex++, false, falseCondition));
        }

        v = trueCondition;
    }
    else
    {
        // concrete execution : 
        switch(n.type)
        {
            case NE: v =  v1 != v2; break;
            case EQ: v = v1 == v2; break;
            case STRICT_EQ: v = v1 === v2; break;
            case STRICT_NE: v = v1 !== v2; break;
            case LT: v = v1 < v2; break;
            case LE: v = v1 <= v2; break;
            case GE: v = v1 >= v2; break;
            case GT: v = v1 > v2; break;
            case PLUS: v = v1 + v2; break;
            case MINUS: v = v1 - v2; break;
            case MUL: v = v1 * v2; break;
            case DIV: v = v1 / v2; break;
            case MOD: v = v1 % v2; break;
            
            default : 
            die_with_message ("unhandled concrete execution of binary operator - n[0] " + 
                n[0] + " n[1] - " + n[1]);
        }
    }
    
    return v; 
}


var hasSeenDOM = false; 
function getNonFalsePC(pc1, pc2)
{
    // check if pc1 is the negation of pc2 or vice-versa.
    var pc1Negation = "NOT ( " + pc1 + " ) ";
    var pc2Negation = " NOT ( " + pc2 + " ) "; 
    var sub1 = pc1.indexOf(pc2Negation);
    var sub2 = pc2.indexOf(pc1Negation);
    var sub3 = pc1.indexOf(pc2);
    
    p(" indices  sub1 = " + sub1 + " sub2 = " + sub2 + " sub3 = " + sub3);
    if(! (sub1 == -1 && sub2 == -1 && sub3 == -1))
        return null;

    return (pc1 + " AND " + pc2);
}

function enumeratePossiblePathConditions(n, x, bOR)
{
    ++clauseCounter;
    var strNodeType = bOR ? "OR": "AND";  
    p ( strNodeType + " Debug - n[0] - " + n[0]);
    p ( strNodeType + " Debug - n[1] - " + n[1]);
    var vlClause = getValue (execute(n[0], x));
    
    addRecordIfAbsent( vlClause, conditionCases );
    
    p ( " value of vlClause - " + vlClause);
       
    var vrClause = getValue (execute(n[1], x));
    addRecordIfAbsent (vrClause, conditionCases);
    var symb = false; 
    if (isSymbolic(vlClause) || isSymbolic(vrClause))
    {
        p ( " Condition Record before processing - " ); printConditionRecords(conditionCases);

        // copy the current true records to new collection of conditions
        var newConditions = new DP_ObCollectionOrdered("index", ReturnRecord);             
        var tConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 
        var fConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 

        var j = 0; 
        var jc = conditionCases.getCount ();
        var mem = null;
        var memF = null; 
        
        // first condition case w/ false results
        // there is only one condition in case of ORs.
        for ( ; j < jc ; j++)
        {
            mem = conditionCases.getAt(j);
            p ( " now processing - " + mem.pc);
            // do not process the clause conditions that do not belong 
            // to this level here 
            if(mem.nestingDepth != clauseCounter)
            {
                newConditions.add(mem);
                continue; 
            }

            if (mem.boolValue)
            {   
                if(bOR)
                {                 
                    // PC conditions that lead to true values
                    // are short-circuited in ORs. 
                    bRet = mem.pc; 
                    var newcond = new ConditionRecord(conditionIndex++, mem.boolValue, mem.pc);
                    newcond.processed = false; 
                    newConditions.add(newcond);
                    tConditions.add(newcond);
                    p  (" adding to true conditions - " + newcond.pc + " " + newcond.boolValue);
                }
                else
                {
                    p  (" adding to true conditions - " + mem.pc + " " + mem.boolValue);
                    tConditions.add(mem);
                }
            }
            else
            {
                if(!bOR)
                {                 
                    // PC conditions that lead to false values
                    // are short-circuited in ANDs. 
                    bRet = mem.pc; 
                    var newcond = new ConditionRecord(conditionIndex++, mem.boolValue, mem.pc);
                    newcond.processed = false;
                    p  (" adding to false conditions - " + newcond.pc + " " + newcond.boolValue);
                    newConditions.add(newcond);
                    fConditions.add(newcond);
                }
                else
                {
                    p  (" adding to false conditions - " + mem.pc + " " + mem.boolValue);
                    fConditions.add(mem);
                }
            }
        }
        
        var cond1 = null;
        var cond2 = null;
        if(bOR)
        { 
            cond1 = fConditions; cond2 = tConditions;    
        }
        else
        { 
            cond1 = tConditions; cond2 = fConditions;    
        }
        
        var c1Count = cond1.getCount();
        var c2Count = cond2.getCount();
        var onePC = "";

        var i = 0;        
        for ( i = 0; i < c1Count ; i++ )
        {                            
            var mem1 = cond1.getAt(i);
            if(!mem1.processed)
            {
                for(j = 0; j < c2Count ; j++)
                {
                    var mem2 = cond2.getAt(j);
                                           
                    var newpc = getNonFalsePC(mem1.pc, mem2.pc); 
                    if(newpc == null)
                        continue; 
                          
                    var newcond = new ConditionRecord(conditionIndex++, mem2.boolValue, newpc);
                    newcond.processed = true; 
                    newConditions.add(newcond);
                }
            }
                            
            onePC += mem1.pc;
            if(i < c1Count - 1)
                onePC += " AND ";                 
        }
        
        var newcond = new ConditionRecord(conditionIndex++, !bOR, onePC);
        newConditions.add(newcond);
        
        conditionCases = newConditions;

        // now demote the clauses to enclosing nesting depth to allow
        // them to be combined to those clauses
        j = 0; 
        jc = conditionCases.getCount ();
        var inLevel = 0;
        for ( ; j < jc ; j++ )
        {                            
            mem = conditionCases.getAt(j);
            if(mem.nestingDepth != clauseCounter)
                continue; 
            else
            {
                if(mem.boolValue)
                    bRet = mem.pc;
                mem.nestingDepth--;
                mem.processed = true; 
            }
        }

        p ( " Condition Record after processing - " ); printConditionRecords(conditionCases);
    }        
    else
    {
        if(bOR)
        {
            bRet = (vlClause || vrClause);
        }
        else
        {
            bRet = (vlClause && vrClause);
        }
    }
    
    --clauseCounter;                
    return bRet;
}

function execute(n, x) {

    var a, f, i, j, r, s, t, u, v;
//    p ( " execute : called " + n + " and x - " + x );
    p ( " Execute : " + getNodeType (n));
    
    switch (n.type) {
      case FUNCTION:
        //p ( " \t func name " + (n.name ? n.name : "null" ) + "func body - " + n.body);
        
        // this creates a function object. anonymous invocations are defined as a 
        // property of the lvalue whereas regular functions get their own scope. 
        // this scope is embedded in the defining scope.
        // symbolic exec : do we need to do something here? 
        //  - prob not. its not a call. 
        if (n.functionForm != DECLARED_FORM) {
            if (!n.name || n.functionForm == STATEMENT_FORM) {
                v = new FunctionObject(n, x.scope);
                if (n.functionForm == STATEMENT_FORM)
                    x.scope.object.__defineProperty__(n.name, v, true);
            } else {
                t = new Object;
                x.scope = {object: t, parent: x.scope};
                try {
                    v = new FunctionObject(n, x.scope);
                    t.__defineProperty__(n.name, v, true, true);
                } finally {
                    x.scope = x.scope.parent;
                }
            }
        }
        break;

      case SCRIPT:
        // scripts may define : functions, variables and then have some code 
        // for exec. fall through to BLOCK takes us to code to be executed.
        // symbolic exec : same as above. 
        //  - prob nothing. 
        t = x.scope.object;
        a = n.funDecls;
        for (i = 0, j = a.length; i < j; i++) {
            s = a[i].name;
            f = new FunctionObject(a[i], x.scope);
            t.__defineProperty__(s, f, x.type != EVAL_CODE);
        }
        
        a = n.varDecls;
        for (i = 0, j = a.length; i < j; i++) {
            u = a[i];
            s = u.name;
            if (u.readOnly && hasDirectProperty(t, s)) {
                throw new TypeError("Redeclaration of const " + s,
                                    u.filename, u.lineno);
            }
            if (u.readOnly || !hasDirectProperty(t, s)) {
                t.__defineProperty__(s, undefined, x.type != EVAL_CODE,
                                     u.readOnly);
            }
        }
        // FALL THROUGH

      case BLOCK:
      
        // this is the highest level where execution starts. 
        // BLOCK stands for a regular PL basic block i.e., function bodies, 
        // scripts to be execed, if-else blocks. 
        // symbolic exec : 
        //  - first step is to give an idea of what has to be execed next. 
        //      for forking symb exec we must know the next instr. 
        //      basically, the way symb exec is achieved here is to 
        //          a. save the exec context ( nested chains of scopes, program condition)
        //          b. set the value of current instr based on diff symb exec branches e.g., 
        //                  x = f(); <- f may return PCondition1 - val1 and PCondition2 - val2.
        //              set x as val1 and append PCondition1 to current program condition.
        //              similarly set x as val2 and append PCondition2 and save it for subsequent execution.
        //              note that by saving execution context, we save the entire environment including 
        //              calling parents. 
        for (i = 0, j = n.length; i < j; i++)
        {
            if ( i + 1 < j )
            {
                // store info of next inst to be executed.
                // if current instruction is a block stmt - then the last stmt
                // points to the next instruction  
                setNextInstruction ( n[i], n[i + 1] );
                //p("\t n[" + i + "] - "  + getNodeType(n[i]) + 
                //    " next instruction - " + getNodeType(n[i].nextInstruction));
            }
            else
            {
                //p("\t n[" + i + "] - "  + getNodeType(n[i]) + 
                //    " next instruction - null");
            }
        }           
        
        for (i = 0, j = n.length; i < j; i++)
        {
            execute(n[i], x);
        }
        break;

      case IF:
                
        // the guard condition may be evaluated symbolically.
        // symb exec : 
        //  - if guard condition is evaluated symbolically, both the then and the
        // else part should be executed. 
        //  - evaluate the guard condition and if its value is symbolic instead of 
        // boolean, keep executing the true branch i.e., the then branch and store
        // else branch for subsequent execution.
          
        conditionValue = execute(n.condition, x);    
        var bool2 = isSymbolic(getValue(conditionValue));
        if ( isSymbolic ( conditionValue ) || bool2)
        {
        
            if(bool2)
                addRecordIfAbsent( getValue(conditionValue), conditionCases );

            p(" Symbolic execution of if condition : symbolic condition - " + conditionValue);
            //p ( " then part - " + n.thenPart);
            //p ( " else part - " + n.elsePart);
            //p ( " next inst - " + n.nextInstruction);
            printConditionRecords(conditionCases);            
            var i = 0;
            var count = conditionCases.getCount();
            var xcTrue = null;
    

            for ( ; i < count; i++)
            {
                var mem = conditionCases.getAt(0);
                conditionCases.drop(mem.index);
                
                xcSaved = cloneObject ( x );
                
                updatePC(xcSaved, mem.pc);
                if ( mem.boolValue )
                {
                    xcSaved.nextInstruction = n.thenPart; 
                    xcTrue = xcSaved;
                }
                else
                {
                    if ( n.elsePart )
                        xcSaved.nextInstruction = n.elsePart;
                    else
                    if ( n.nextInstruction )
                        xcSaved.nextInstruction = n.nextInstruction;
                    else
                        xcSaved.nextInstruction = n.thenPart[0].nextInstruction;                    
                }

                xcSaved.notamper_index = RRIndex++;
                p ( " adding a pending execution notamper_index - " + 
                    xcSaved.notamper_index + " next - " + xcSaved.nextInstruction); 

                PendingExecutions.add( xcSaved );                
                printPendingExecutions( PendingExecutions ); 
            }                        
      
            // reset the conditioncases 
            // conditionIndex should be reset when resetting the 
            // collection of conditions --> generally ifs, assignments, groups, hooks
            // this helps to number the executed conditional clauses left to right
            // a || b || c --> a : 1, b : 2 , c : 3 
            // this is used to symbolically simulate short-circuit execution
            conditionCases.clear();      
            conditionIndex = 0 ;
        
            // Resume execution of one of the true conditions 
            p ( "resuming execution of " + xcTrue.notamper_index + " next - " + 
                xcTrue.nextInstruction + " pc - " + xcTrue.programCondition);
            p ( "\t removing from pending list - ");
            PendingExecutions.drop ( xcTrue.notamper_index )
            x.programCondition = xcTrue.programCondition; 
            ExecutionContext.current = x;
            execute(n.thenPart, x);     
        }
        else
        {
            // if condition does not involve any symbolic variables, execute it 
            // concretely. Realize that while symbolically executing a piece of code
            // this helps us to evaluate undesired embedded conditionals concretely.
            // undesired here refers to conditionals based on non-form input values / properties. 
            // we are only interested in computation done on form inputs (symbolically initialized
            // in simulated DOM).
            p (" Concrete execution of if condition");
            if (getValue(conditionValue))
                execute(n.thenPart, x);
            else if (n.elsePart)
                execute(n.elsePart, x);
        }
        break;

      case SWITCH:
      // handling of switch is done as "if-then-else" except that there are 
      // symb exec : numberofcases - 1 pending executions.
        
        var s = getValue(execute(n.discriminant, x));
        var t = n.discriminant.value;
            
        // p ( "  \t n - " + n + "\n\t discriminant - " + n.discriminant + " name - " + t + " value - " + s) ;     

        a = n.cases;
        var matchDefault = false;

        if ( isSymbolic ( s ) && !x.switchCase)
        {
            if (n.discriminant.type != IDENTIFIER)
            {
                die_with_message ( " NoTamper impl currently only allows switch discriminant to be a variable. Please simplify this - " + n.discriminant);
            }
        
            // now we can simply search discriminant identifier in the enclosing scopes. 
            //var t = n.discriminant.value; 
            for (var sc = x.scope; sc; sc = sc.parent) {
                if (hasDirectProperty(sc.object, t))
                    break;
            }
            
            if ( sc == null)
            {
                die_with_message ( " NoTamper impl failed to find the switch discriminant variable. Please simplify this - " + n.discriminant);
            }
            
            for (var i = 0, j = a.length; ;) 
            {
//                p ( " \t next consideration - " + " i - " + i + " j - " + j + " = " + a[i]);
                var t1 = a[i];                       // next case (might be default!)
                if (t1.type == CASE) 
                {                
                    var u = getValue(execute(t1.caseLabel, x)); 
                    // clone the exec context;
                    //p ( " assigning property - " + t + " prop val - " + s + 
                    //    " to assign value - " + u + " type - " + (typeof u));
                    //sc.object[s] = "" + u;
                    sc.object.__defineProperty__(t, u, true);
                    //p ( " scope  after updating the value of disc - "); printScope ( " \t " , sc);

                    var xcSaved = cloneObject ( x );
                    var pc1 = s + " == " + u;
                    updatePC(xcSaved, pc1);
                    xcSaved.nextInstruction = n;
                    
                    // sc.object[s] = "defaultSave";
                    sc.object.__defineProperty__(t, "defaultValue", true);
                    xcSaved.switchCase = true;             
                    xcSaved.notamper_index = RRIndex++;
                    //p ( " adding a pending execution after var init " + t + " notamper_index - " + 
                    //    xcSaved.notamper_index + " return value - " + u + " next - " + n); 
                    PendingExecutions.add( xcSaved );
                    printPendingExecutions( PendingExecutions ); 
                } 
                
                if ( ++i == j)
                    break;
            }

            for (var i = 0, j = a.length; ;) 
            {
                //p ( " \t next consideration - " + " i - " + i + " j - " + j + " = " + a[i]);
                var t1 = a[i];                       // next case (might be default!)
                if (t1.type != CASE) 
                {
                    //u = "defaultValue";
                    var pc2 = ""  + s + " == defaultValue";
                    updatePC (x, pc2);
                    break;
                    //sc.object[t] = u;
                }
                
                if ( ++i == j)
                    break;
            }
            
            // fall through and concrete execute the default case.         
        }
        
        // concrete exec 
        p ( " entering concrete exec - PC : " + x.programCondition);
      switch_loop:
        for (i = 0, j = a.length; ; i++) {
            if (i == j) {
                if (n.defaultIndex >= 0) {
                    i = n.defaultIndex - 1; // no case matched, do default
                    matchDefault = true;
                    continue;
                }
                break;                      // no default, exit switch_loop
            }
            t = a[i];                       // next case (might be default!)
            if (t.type == CASE) {
                u = getValue(execute(t.caseLabel, x));
            } else {
                if (!matchDefault)          // not defaulting, skip for now
                    continue;
                u = s;                      // force match to do default
            }
            if (u === s) {
                for (;;) {                  // this loop exits switch_loop
                    if (t.statements.length) {
                        try {
                            execute(t.statements, x);
                        } catch (e if e == BREAK && x.target == n) {
                            x.switchCase = false;
                            break switch_loop;
                        }
                    }
                    if (++i == j)
                    {
                        x.switchCase = false;
                        break switch_loop;
                    }
                    t = a[i];
                }
                // NOT REACHED
            }
        }
        break;

      case FOR:
      // generally loops are not used to validate an individual form input. 
      // symb exec : 
        // - require the condition of loops to be non-symbolic i.e., only allow
        // loops to execute in concrete mode. Realize that loop bodies may be 
        // symbolic in turn also program condition to reach the loop may be 
        // symbolic. 
        
        if ( FOR == n.type )
            p ( " Execute : FOR Loop ");
        n.setup && getValue(execute(n.setup, x));
        // FALL THROUGH
      case WHILE:
        if ( WHILE == n.type )
            p ( " Execute : WHILE ");
        // while (!n.condition || getValue(execute(n.condition, x))) {
         while (!n.condition) {
            var condValue = getValue(execute(n.condition, x));
            if ( isSymbolic (condValue) )
            {
                die_with_message ( " NoTamper: Does not execute loops with symbolic conditions - " + 
                    " condition - " + n.condition + " loop - " + n);
            }
            
            if (!condValue)
                break;
                
            try {
                execute(n.body, x);
            } catch (e if e == BREAK && x.target == n) {
                break;
            } catch (e if e == CONTINUE && x.target == n) {
                continue;
            }
            n.update && getValue(execute(n.update, x));
        }
        break;

      case FOR_IN:
        // TODO ? symbolic execution
        
        p ( " Execute : FOR_IN ");
        u = n.varDecl;
        if (u)
            execute(u, x);
        r = n.iterator;
        s = execute(n.object, x);
        v = getValue(s);

        // ECMA deviation to track extant browser JS implementation behavior.
        t = (v == null && !x.ecmaStrictMode) ? v : toObject(v, s, n.object);
        a = [];
        for (i in t)
            a.push(i);
        for (i = 0, j = a.length; i < j; i++) {
            putValue(execute(r, x), a[i], r);
            try {
                execute(n.body, x);
            } catch (e if e == BREAK && x.target == n) {
                break;
            } catch (e if e == CONTINUE && x.target == n) {
                continue;
            }
        }
        break;

      case DO:
      // same as in for / while loop - demand the do-while condition to be 
      // concrete. 
        do {
            try {
                execute(n.body, x);
            } catch (e if e == BREAK && x.target == n) {
                break;
            } catch (e if e == CONTINUE && x.target == n) {
                continue;
            }
            var condValue = getValue(execute(n.condition, x));
            if ( isSymbolic (condValue) )
            {
                die_with_message ( " NoTamper: Does not execute loops with symbolic conditions - " + 
                    " condition - " + n.condition + " loop - " + n);
            }

        } while (condValue);
        break;

      case BREAK:
      case CONTINUE:
      // symb execution : nothing specific 
        x.target = n.target;
        throw n.type;

      case TRY:
        // TODO : Symbolic execution ? 
        try {
            execute(n.tryBlock, x);
        } catch (e if e == THROW && (j = n.catchClauses.length)) {
            e = x.result;
            x.result = undefined;
            for (i = 0; ; i++) {
                if (i == j) {
                    x.result = e;
                    throw THROW;
                }
                t = n.catchClauses[i];
                x.scope = {object: {}, parent: x.scope};
                x.scope.object.__defineProperty__(t.varName, e, true);
                try {
                    if (t.guard && !getValue(execute(t.guard, x)))
                        continue;
                    execute(t.block, x);
                    break;
                } finally {
                    x.scope = x.scope.parent;
                }
            }
        } finally {
            if (n.finallyBlock)
                execute(n.finallyBlock, x);
        }
        break;

      case THROW:
      // TODO:  symbolic execution 
        x.result = getValue(execute(n.exception, x));
        throw THROW;

      case RETURN:
      {
        p ( " Execute : RETURN : " + n.value + " PC = " + x.programCondition);
        //p ( " return node - " + n);
        //p ( " execution context - "); 
        //printXC ( x );
        x.result = getValue(execute(n.value, x));
        if ( x.programCondition != "true" )
        {
            var crntFn = x.callee; 
            var callerFn = x.caller; 
            p ( " current function node - " + crntFn + " caller - " + callerFn);
            var formals = crntFn.node.params;
            var actuals = [];
            if ( formals != null )
            {
                p ( " \t\t formals - " + formals);
                for ( var i = 0 ; i < formals.length ; i++)
                {
                    var t = "" + formals[i];
                    p ( " \t\t\t formal : " + t + " actual - " + x.scope.object[t]);
                    actuals[i] = x.scope.object[t];
                }
            }
            p ( " actuals  - " + actuals);
            rr = new ReturnRecord ( RRIndex++ , crntFn.node.name, x.result, x.programCondition, actuals);
            p ( " return record #" + rr.index +" \t funcName : " + rr.funcName + " \t returns = " + rr.retValue + 
                " \t pc = " + rr.pc);

            ReturnRecords.add( rr );
            p ( " stored the result of function return - " + x.programCondition +  " return value = " + 
                x.result);
            p ( " collection after storing the result - ");
            printReturnRecords ( ReturnRecords );
//            p ( " current function - " + crntFn );
//            p ( " left over - " + leftOver);
            executeNextPending ( x );
            
        }   
        throw RETURN;
      }
      case WITH:
        // TODO : No Symbolic exec
        //      p ( " Execute : WITH ");
        r = execute(n.object, x);
        t = toObject(getValue(r), r, n.object);
        x.scope = {object: t, parent: x.scope};
        try {
            execute(n.body, x);
        } finally {
            x.scope = x.scope.parent;
        }
        break;

      case VAR:
      case CONST:              
        // if the var initialization is of the form var v = f();
        // fork symbolic execution if the called function was symbolically
        // executed.
        for (i = 0, j = n.length; i < j; i++) 
        {
            forkSymbolicExecution ( n[i].name , n[i].initializer , x, n.nextInstruction, n.type);                     
        }
        break;

      case DEBUGGER:
        throw "NYI: " + tokens[n.type];

      case SEMICOLON:
        // fixed the nextInstruction of expression to be that
        // of current instruction  
        if (n.expression)
        {
            n.expression.nextInstruction = n.nextInstruction;
            x.result = getValue(execute(n.expression, x));
        }
        break;

      case LABEL:
      // TODO: Any special handling here? 
        try {
            execute(n.statement, x);
        } catch (e if e == BREAK && x.target == n) {
        }
        break;

      case COMMA:
      // TODO : Special handling? 
        for (i = 0, j = n.length; i < j; i++)
            v = getValue(execute(n[i], x));
        break;

      case ASSIGN:
        var r = execute(n[0], x);

        t = n[0].assignOp;
        //p( " \t\t r = " + r + " t = " + t );
        
        if ( n[0].type == IDENTIFIER && n[0].value == "notamper_execution_ends")
        {
            p ( "########################### Reached end of execution ");
            printReturnRecords ( ReturnRecords );
        }
        
        if (t)
            u = getValue(r);
        
        if (n[1].type != CALL)
        {
            v = getValue(execute(n[1], x));
        }
        else
        {
          //  var x1R = x.calledExecutionContext_result; 
          //  var x1PC = x.calledExecutionContext_programCondition;
          //  p ( " RHS - function call. return - " + x1R + " pc - " + x1PC);

            // fork symbolic execution if function is symbolically executed. 
            // 1 : lhs
            // 2 : rhs expression 
            // 3 : execution context;  
            p ( " checkout assign stmt - " + n[0] + " = " + n[1] + " and next - " + n.nextInstruction);
            v = forkSymbolicExecution ( n[0].value , n [1] , x, n.nextInstruction, n.type);                            
        }
        
        if (t) {
            die_with_message ( " sym exec not handled for assign stmt - " + n[0].value + " =  " + n[1]);
            
            switch (t) {
              case BITWISE_OR:  v = u | v; break;
              case BITWISE_XOR: v = u ^ v; break;
              case BITWISE_AND: v = u & v; break;
              case LSH:         v = u << v; break;
              case RSH:         v = u >> v; break;
              case URSH:        v = u >>> v; break;
              case PLUS:        v = u + v; break;
              case MINUS:       v = u - v; break;
              case MUL:         v = u * v; break;
              case DIV:         
			  	v = u / v; 
				break;
              case MOD:         v = u % v; break;
            }
        }
        putValue(r, v, n[0]);
        break;

      case HOOK:
      // symb exec : Similar to if-then-else
        conditionValue = execute(n[0], x);    
        if ( isSymbolic ( conditionValue ) )
        {
            p(" Symbolic execution of hook condition : symbolic condition - " + conditionValue);
            if ( toExecute != null )
            {
                toExecute.nextInstruction = n[2];
                toExecute.notamper_index = RRIndex ++ ;
                p ( " adding a pending execution notamper_index - " + 
                    toExecute.notamper_index + " next - " + toExecute.nextInstruction); 
                PendingExecutions.add( toExecute );
                toExecute = null;
                printPendingExecutions( PendingExecutions ); 
            }
                        
            v = execute(n[1], x);     
        }
        else
        {
            // execute hook concretely
            p (" Concrete execution of hook condition");
            if (getValue(conditionValue))
                v = execute(n[1], x);
            else if (n.elsePart)
                v = execute(n[2], x);
        }

        break;

      case OR:

        var bRet = false;
        bRet = enumeratePossiblePathConditions(n, x, true);
//        ++clauseCounter; 
//        p ( " OR Debug - n[0] - " + n[0]);
//        p ( " OR Debug - n[1] - " + n[1]);
//        var vlOr = getValue (execute(n[0], x));
//        
//        addRecordIfAbsent( vlOr, conditionCases );
//        
//        p ( " value of vlOr - " + vlOr);
//           
//        var vrOr = getValue (execute(n[1], x));
//        addRecordIfAbsent (vrOr, conditionCases);
//        var symb = false; 
//        if (isSymbolic(vlOr) || isSymbolic(vrOr))
//        {
//            p ( " Condition Record before processing - " ); printConditionRecords(conditionCases);

//            // copy the current true records to new collection of conditions
//            var newConditions = new DP_ObCollectionOrdered("index", ReturnRecord);             
//            var tConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 
//            var fConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 

//            var j = 0; 
//            var jc = conditionCases.getCount ();
//            var mem = null;
//            var memF = null; // first condition case w/ false results
//                            // there is only one condition in case of ORs.
//            for ( ; j < jc ; j++)
//            {
//                mem = conditionCases.getAt(j);
//                p ( " now processing - " + mem.pc);
//                // do not process the clause conditions that do not belong 
//                // to this level here 
//                if(mem.nestingDepth != clauseCounter)
//                {
//                    newConditions.add(mem);
//                    continue; 
//                }

//                if (mem.boolValue)
//                {                    
//                    // PC conditions that lead to true values
//                    // are short-circuited. 
//                    bRet = mem.pc; 
//                    var newcond = new ConditionRecord(conditionIndex++, true, mem.pc);
//                    newcond.processed = false; 
//                    newConditions.add(newcond);
//                    tConditions.add(newcond);
//                }
//                else
//                {
//                    p  (" adding to false repository - " + mem.pc + " " + mem.boolValue);
//                    fConditions.add(mem);
//                }
//            }
//            
//            var i = 0;
//            j = 0; 
//            var fCount = fConditions.getCount();
//            var tCount = tConditions.getCount();
//            var falsePC = "";
//            for ( ; i < fCount ; i++ )
//            {                            
//                var memF = fConditions.getAt(i);
//                p (" creating true records - " + memF.pc);
//                if(!memF.processed)
//                {
//                    for(j = 0; j < tCount ; j++)
//                    {
//                        var memT = tConditions.getAt(j);
//                        //if(memT.proceseed)
//                        //    continue; 
//                                               
//                        var newpc = getNonFalsePC(memF.pc, memT.pc); //memF.pc + " AND " + memT.pc;
//                        if(newpc == null)
//                            continue; 
//                              
//                        var newcond = new ConditionRecord(conditionIndex++, memT.boolValue, newpc);
//                        newcond.processed = true; 
//                        newConditions.add(newcond);
//                    }
//                }
//                                
//                falsePC += memF.pc;
//                if(i < fCount - 1)
//                    falsePC += " AND ";                 
//            }
//            
//            var newcond = new ConditionRecord(conditionIndex++, false, falsePC);
//            newConditions.add(newcond);
//            
//            conditionCases = newConditions;

//            // now demote the clauses to enclosing nesting depth to allow
//            // them to be combined to those clauses
//            j = 0; 
//            jc = conditionCases.getCount ();
//            var inLevel = 0;
//            for ( ; j < jc ; j++ )
//            {                            
//                mem = conditionCases.getAt(j);
//                if(mem.nestingDepth != clauseCounter)
//                    continue; 
//                else
//                {
//                    if(mem.boolValue)
//                        bRet = mem.pc;
//                    mem.nestingDepth--;
//                    mem.processed = true; 
//                }
//            }


//            p ( " Condition Record after processing - " ); printConditionRecords(conditionCases);
//        }        
//        else
//        {
//            bRet = (vlOr || vrOr);
//        }
//        
//        --clauseCounter;        
        v = bRet; 
        break;

      case AND:
        var bRet = enumeratePossiblePathConditions(n, x, false);
        v = bRet; 
        break;
//        p ( " AND Debug - n[0] - " + n[0]);
//        p ( " AND Debug - n[1] - " + n[1]);
//        ++clauseCounter;
//        var bRet = false; 
//        var vlAnd = getValue (execute(n[0], x));
//        addRecordIfAbsent( vlAnd, conditionCases );

//        var vrAnd = getValue (execute(n[1], x));
//        addRecordIfAbsent( vrAnd, conditionCases );

//        var symb = false; 
//        if (isSymbolic(vlAnd) || isSymbolic(vrAnd))
//        {
//            p ( " Condition Record before processing - " ); printConditionRecords(conditionCases);

//            var tConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 
//            var fConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 
//            var newConditions = new DP_ObCollectionOrdered("index", ReturnRecord); 
//            
//            var j = 0; 
//            var jc = conditionCases.getCount ();
//            var mem = null;
//            var memT = null; // first condition case w/ true results
//                            // there is only one condition in case of ANDs.
//            for ( ; j < jc ; j++)
//            {
//                mem = conditionCases.getAt(j);
//                // do not process the clause conditions that do not belong 
//                // to this level here 
//                if(mem.nestingDepth != clauseCounter)
//                {
//                    newConditions.add(mem);
//                    continue; 
//                }

//                if (!mem.boolValue)// && mem.processed)
//                {
//                    // PC conditions that lead to false values
//                    // are short-circuited. 
//                    bRet = mem.pc; 
//                    var newcond = new ConditionRecord(conditionIndex++, false, mem.pc);
//                    newcond.processed = true; 
//                    newConditions.add(newcond);
//                    fConditions.add(newcond);
//                }
//                else                
//                {
//                    tConditions.add(mem);
//                }
//            }
//            
//            j = 0;
//            var i = 0; 
//            var fCount = fConditions.getCount();
//            var tCount = tConditions.getCount();
//            var truePC = "";

//            for ( ; i < tCount ; i++ )
//            {
//               var memT = tConditions.getAt(i);

//                for(j = 0; j < fCount ; j++)
//                {
//                    var memF = fConditions.getAt(j);
//                    
//                    var newpc = getNonFalsePC(memT.pc, memF.pc); 
//                    if(newpc == null)
//                        continue; 
//                          
//                    var newcond = new ConditionRecord(conditionIndex++, memF.boolValue, newpc);
//                    newcond.processed = true; 
//                    newConditions.add(newcond);
//                }
//                
//                truePC += memT.pc;
//                if(i < tCount - 1)
//                    truePC += " AND ";                 
//            }
//            
//            var newcond = new ConditionRecord(conditionIndex++, true, truePC);
//            newConditions.add(newcond);

//            conditionCases = newConditions;
//            
//           // now demote the clauses to enclosing nesting depth to allow
//            // them to be combined to those clauses
//            j = 0; 
//            jc = conditionCases.getCount ();
//            var inLevel = 0;
//            for ( ; j < jc ; j++ )
//            {                            
//                mem = conditionCases.getAt(j);
//                if(mem.nestingDepth != clauseCounter)
//                    continue; 
//                else
//                {
//                    mem.nestingDepth--;
//                    mem.processed = true; 
//                }
//            }

//            p ( " Condition Record after processing - " ); printConditionRecords(conditionCases);
//        }        
//        else
//        {
//            bRet = (vlAnd && vrAnd);
//        }
//        
//        --clauseCounter;        
//        v = bRet;
//        break;

      case BITWISE_OR:
        die_with_message ( " BITWISE OR Not handled - n[0]" + n[0] + " \n n[1] - " + n[1]);
        v = getValue(execute(n[0], x)) | getValue(execute(n[1], x));
        break;

      case BITWISE_XOR:
        die_with_message ( " BITWISE XOR Not handled - n[0]" + n[0] + " \n n[1] - " + n[1]);
        v = getValue(execute(n[0], x)) ^ getValue(execute(n[1], x));
        break;

      case BITWISE_AND:
        die_with_message ( " BITWISE AND Not handled - n[0]" + n[0] + " \n n[1] - " + n[1]);
        v = getValue(execute(n[0], x)) & getValue(execute(n[1], x));
        break;

      case EQ:
      case NE:
      case STRICT_EQ:
      case STRICT_NE:
      case LT:
      case LE:
      case GE:
      case GT:
      case PLUS:
      case MINUS:
      case MUL:
      case DIV:
      case MOD:
      
        // overloaded function
        // if symb exec : returns the true condition i.e., PC for NE being true
        // else returns the outcome of the evaluation i.e., v1 != v2
        v = executeBinaryOperator(n,x);
        break;

      case IN:
        die_with_message(" In operator not handled for - " + n[0] + 
            " and n[1] - " + n[1]);
        v = getValue(execute(n[0], x)) in getValue(execute(n[1], x));
        break;

      case INSTANCEOF:
        die_with_message(" INSTANCEOF not handled for - " + n[0] + 
            " and n[1] - " + n[1]);
        t = getValue(execute(n[0], x));
        u = getValue(execute(n[1], x));
        if (isObject(u) && typeof u.__hasInstance__ == "function")
            v = u.__hasInstance__(t);
        else
            v = t instanceof u;
        break;

      case LSH:
        die_with_message(" LSH not handled for - " + n[0] + 
            " and n[1] - " + n[1]);

        v = getValue(execute(n[0], x)) << getValue(execute(n[1], x));
        break;

      case RSH:
        die_with_message(" RSH not handled for - " + n[0] + 
            " and n[1] - " + n[1]);

        v = getValue(execute(n[0], x)) >> getValue(execute(n[1], x));
        break;

      case URSH:
        die_with_message(" URSH not handled for - " + n[0] + 
            " and n[1] - " + n[1]);

        v = getValue(execute(n[0], x)) >>> getValue(execute(n[1], x));
        break;


      case DELETE:
        die_with_message(" DELETE not handled for - " + n[0]);

        t = execute(n[0], x);
        v = !(t instanceof Reference) || delete t.base[t.propertyName];
        break;

      case VOID:
        getValue(execute(n[0], x));
        break;

      case TYPEOF:
      die_with_message(" TYPEOF not handled for - " + n[0]);

        t = execute(n[0], x);
        if (t instanceof Reference)
            t = t.base ? t.base[t.propertyName] : undefined;
        v = typeof t;
        break;

      case NOT:
        p(" Executing NOT - " + n[0]);
        printConditionRecords(conditionCases);
         
        v = getValue(execute(n[0], x));
        if(isSymbolic(v))
        {
            // flip all values of condition records; 
            p(" Executing NOT symbolically ");
            
            printConditionRecords(conditionCases);
            
            var tmpCases = new DP_ObCollectionOrdered("index", ConditionRecord); 
            var i = 0; 
            var count = conditionCases.getCount();
            for ( ; i < count ; i++)
            {
                var mem = conditionCases.getAt(i);
                p ( " \t Condition Case #" + mem.index + " \t : " + 
                    mem.boolValue + " \t pc = " + mem.pc + 
                    " \t processed - " + mem.processed);
                mem.boolValue = !mem.boolValue;
                tmpCases.add(mem);
            }
            conditionCases = tmpCases; 
            printConditionRecords(conditionCases);
        }
        else
        {
            v = !v;
        }
        break;

      case BITWISE_NOT:
          die_with_message ( " BITWISE NOT Not handled - n[0]" + n[0]);
        v = ~getValue(execute(n[0], x));
        break;

      case UNARY_PLUS:
          die_with_message ( " UNARY_PLUS Not handled - n[0]" + n[0]);

        v = +getValue(execute(n[0], x));
        break;

      case UNARY_MINUS:
        die_with_message ( " UNARY_MINUS Not handled - n[0]" + n[0]);

        v = -getValue(execute(n[0], x));
        break;

      case INCREMENT:
      case DECREMENT:
      die_with_message ( " INCREMENT/DECREMENT Not handled - n[0]" + n[0]);

        t = execute(n[0], x);
        u = Number(getValue(t));
        if (n.postfix)
            v = u;
        putValue(t, (n.type == INCREMENT) ? ++u : --u, n[0]);
        if (!n.postfix)
            v = u;
        break;

      case DOT:
        r = execute(n[0], x);
        t = getValue(r);
        u = n[1].value;
        v = new Reference(toObject(t, r, n[0]), u, n);

        break;

      case INDEX:
        r = execute(n[0], x);
        t = getValue(r);
        u = getValue(execute(n[1], x));
        v = new Reference(toObject(t, r, n[0]), String(u), n);
        break;

      case LIST:
        // Curse ECMA for specifying that arguments is not an Array object!
        v = {};
        for (i = 0, j = n.length; i < j; i++) {
            value = execute(n[i], x);
            u = getValue(value);
            v.__defineProperty__(i, u, false, false, true);
        }
        v.__defineProperty__('length', i, false, false, true);
        break;

      case CALL:
        
      //p (" n[0] - " + n[0] + " n[1] - " + n[1]);
        r = execute(n[0], x);
        a = execute(n[1], x);
        f = getValue(r);

        var body = f.node.body;
        //p(" body - " + f + " f.body - " + f.body + " f.node.body" + f.node.body);
        if (! isBooleanReturn(r, body))
        {
            v = "";
        }
        else
        {
            
            if (isPrimitive(f) || typeof f.__call__ != "function") {
                throw new TypeError(r + " is not callable",
                                    n[0].filename, n[0].lineno);
            }
            t = (r instanceof Reference) ? r.base : null;
            if (t instanceof Activation)
                t = null;
            v = f.__call__(t, a, x);
        }
        break;

      case NEW:
      case NEW_WITH_ARGS:
        r = execute(n[0], x);
        f = getValue(r);
        if (n.type == NEW) {
            a = {};
            a.__defineProperty__('length', 0, false, false, true);
        } else {
            a = execute(n[1], x);
        }
        if (isPrimitive(f) || typeof f.__construct__ != "function") {
            throw new TypeError(r + " is not a constructor",
                                n[0].filename, n[0].lineno);
        }
        v = f.__construct__(a, x);
        break;

      case ARRAY_INIT:
        v = [];
        for (i = 0, j = n.length; i < j; i++) {
            if (n[i])
                v[i] = getValue(execute(n[i], x));
        }
        v.length = j;
        break;

      case OBJECT_INIT:
        v = {};
        for (i = 0, j = n.length; i < j; i++) {
            t = n[i];
            if (t.type == PROPERTY_INIT) {
                v[t[0].value] = getValue(execute(t[1], x));
            } else {
                f = new FunctionObject(t, x.scope);
                u = (t.type == GETTER) ? '__defineGetter__'
                                       : '__defineSetter__';
                v[u](t.name, thunk(f, x));
            }
        }
        break;

      case NULL:
        v = null;
        break;

      case THIS:
        v = x.thisObject;
        break;

      case TRUE:
        v = true;
        break;

      case FALSE:
        v = false;
        break;

      case IDENTIFIER:
        for (s = x.scope; s; s = s.parent) {
            if (n.value in s.object)
                break;
        }
        v = new Reference(s && s.object, n.value, n);
        //v.notamper_symbolic = n.notamper_symbolic;
        //p("\t creating a new reference - " + s + " object - " + v + " \n");

        break;

      case NUMBER:
      case STRING:
      case REGEXP:
        v = n.value;
        break;

      case GROUP:
        v = execute(n[0], x);
        break;

      default:
        throw "PANIC: unknown operation " + n.type + ": " + uneval(n);
    }

    return v;
}

function isSymbolic ( v )
{
    var isS = false; 
  
    v = "" + v;  
//    if ( v instanceof String )
    {
//        p ( " v != null : " + (v != null) + " v.indexOf(_notamper_symbolic) " + 
//            v.indexOf ("_notamper_symbolic"));
        isS = ((v != null) && (v.indexOf("_notamper_symbolic") != -1));
    }
//    p ( " isSymbolic : " + isS + " for - " + v);
    return isS;
}


function Activation(f, a) {
    for (var i = 0, j = f.params.length; i < j; i++)
        this.__defineProperty__(f.params[i], a[i], true);
    this.__defineProperty__('arguments', a, true);
}

// Null Activation.prototype's proto slot so that Object.prototype.* does not
// pollute the scope of heavyweight functions.  Also delete its 'constructor'
// property so that it doesn't pollute function scopes.  But first, we must
// copy __defineProperty__ down from Object.prototype.

Activation.prototype.__defineProperty__ = Object.prototype.__defineProperty__;
Activation.prototype.__proto__ = null;
delete Activation.prototype.constructor;

function FunctionObject(node, scope) {
    this.node = node;
    this.scope = scope;
    this.__defineProperty__('length', node.params.length, true, true, true);
    var proto = {};
    this.__defineProperty__('prototype', proto, true);
    proto.__defineProperty__('constructor', this, false, false, true);
}

var FOp = FunctionObject.prototype = {
    // Internal methods.
    __call__: function (t, a, x) {
        var x2 = new ExecutionContext(FUNCTION_CODE);
        x2.thisObject = t || global;
        x2.caller = x;
        x2.callee = this;
        a.__defineProperty__('callee', this, false, false, true);
        var f = this.node;
        x2.scope = {object: new Activation(f, a), parent: this.scope};
        ExecutionContext.current = x2;
        try {
            execute(f.body, x2);
        } catch (e if e == RETURN) {
            x.calledExecutionContext_result = x2.result;
            x.calledExecutionContext_programCondition = x2.programCondition; 
            return x2.result;
        } catch (e if e == THROW) {
            x.result = x2.result;
            x.calledExecutionContext_result = x2.result;
            x.calledExecutionContext_programCondition = x2.programCondition;
            throw THROW;
        } finally {
            x.calledExecutionContext_result = x2.result;
            x.calledExecutionContext_programCondition = x2.programCondition;
            ExecutionContext.current = x;
            //x.programCondition = x2.programCondition;
        }
        return undefined;
    },

    __construct__: function (a, x) {
        var o = new Object;
        var p = this.prototype;
        if (isObject(p))
            o.__proto__ = p;
        // else o.__proto__ defaulted to Object.prototype

        var v = this.__call__(o, a, x);
        if (isObject(v))
            return v;
        return o;
    },

    __hasInstance__: function (v) {
        if (isPrimitive(v))
            return false;
        var p = this.prototype;
        if (isPrimitive(p)) {
            throw new TypeError("'prototype' property is not an object",
                                this.node.filename, this.node.lineno);
        }
        var o;
        while ((o = v.__proto__)) {
            if (o == p)
                return true;
            v = o;
        }
        return false;
    },

    // Standard methods.
    toString: function () {
        return this.node.getSource();
    },

    apply: function (t, a) {
        // Curse ECMA again!
        if (typeof this.__call__ != "function") {
            throw new TypeError("Function.prototype.apply called on" +
                                " uncallable object");
        }

        if (t === undefined || t === null)
            t = global;
        else if (typeof t != "object")
            t = toObject(t, t);

        if (a === undefined || a === null) {
            a = {};
            a.__defineProperty__('length', 0, false, false, true);
        } else if (a instanceof Array) {
            var v = {};
            for (var i = 0, j = a.length; i < j; i++)
                v.__defineProperty__(i, a[i], false, false, true);
            v.__defineProperty__('length', i, false, false, true);
            a = v;
        } else if (!(a instanceof Object)) {
            // XXX check for a non-arguments object
            throw new TypeError("Second argument to Function.prototype.apply" +
                                " must be an array or arguments object",
                                this.node.filename, this.node.lineno);
        }

        return this.__call__(t, a, ExecutionContext.current);
    },

    call: function (t) {
        // Curse ECMA a third time!
        var a = Array.prototype.splice.call(arguments, 1);
        return this.apply(t, a);
    }
};

// Connect Function.prototype and Function.prototype.constructor in global.
reflectClass('Function', FOp);

// Help native and host-scripted functions be like FunctionObjects.
var Fp = Function.prototype;
var REp = RegExp.prototype;

if (!('__call__' in Fp)) {
    Fp.__defineProperty__('__call__', function (t, a, x) {
        // Curse ECMA yet again!
        a = Array.prototype.splice.call(a, 0, a.length);
        return this.apply(t, a);
    }, true, true, true);

    REp.__defineProperty__('__call__', function (t, a, x) {
        a = Array.prototype.splice.call(a, 0, a.length);
        return this.exec.apply(this, a);
    }, true, true, true);

    Fp.__defineProperty__('__construct__', function (a, x) {
        a = Array.prototype.splice.call(a, 0, a.length);
        return this.__applyConstructor__(a);
    }, true, true, true);

    // Since we use native functions such as Date along with host ones such
    // as global.eval, we want both to be considered instances of the native
    // Function constructor.
    Fp.__defineProperty__('__hasInstance__', function (v) {
        return v instanceof Function || v instanceof global.Function;
    }, true, true, true);
}

function thunk(f, x) {
    return function () { return f.__call__(this, arguments, x); };
}

function evaluate(s, f, l) {
    if (typeof s != "string")
        return s;
    
    print (" in evaluate \n");

    var x = ExecutionContext.current;
    var x2 = new ExecutionContext(GLOBAL_CODE);
    ExecutionContext.current = x2;
    try {
        execute(parse(s, f, l), x2);
    } catch (e if e == THROW) {
        if (x) {
            x.result = x2.result;
            throw THROW;
        }
        throw x2.result;
    } finally {
        ExecutionContext.current = x;
    }
    return x2.result;
}

/*********************************************************** notamper start **/
var toExecute ;
var leftOver ;

function p (str)
{
    str = str.replace(/_notamper_symbolic/g, "_S");
    print(str);
}

function getXCType( xct )
{
    if (GLOBAL_CODE == xct) 
        return "GLOBAL_CODE";
    
    if (EVAL_CODE == xct)
        return "EVAL_CODE";
    
    if(FUNCTION_CODE == xct)
        return "FUNCTION_CODE";
        
    return "UNDEFINED";
}


// get the string representation of the properties 
// and values of the object ob. indent each one of them
// by 'indent' space on the left. 
function printObject( indent, ob )
{
    str = "";
    var t = typeof ob; 
    if ( t == "object" )
    {
        str += "{ ";
        for ( var prop in ob )
        {
//            str += indent + " property - " + prop + " value - ";
            str += prop + " : ";
            val = ob[prop];
            tp = typeof val; 
            if( tp == "object" )
            { 
                str += printObject ( indent + " \t ", val );
            }
            else
            {
                if ( tp == "function" )
//                    str += indent + " FUNC BODY";
                    str += " FUNC_BODY ";                    
                else
//                    str += indent + val;
                    str += val;        
            }
            str += " , ";
        }
        str += " } ";
    }
    else
    {
        if ( t == "function" )
            str += " FUNC_BODY";
//            str += indent + " FUNC BODY";
        else
            str += ob ;
//            str += indent + ob ;  
    }
       
    str +=  " } ";
    return str; 
}
    
function printScope ( indent, sc )
{
    // recursively print all scope until the parent is null
    i = 0; 
    for (s = sc; s ; s = s.parent) 
    {
        ob = s.object;
        if ( s.parent == null)
            break;
        p ( indent + " scope - \n" + printObject (indent + "\t", ob));
    }    
}

function printXC ( xc )
{
    p ( "  ----------- printing execution context ----------- ");
    p ( " \t current - " + xc.current);
    p ( " \t caller - " + xc.caller);
    
    var f1 = xc.callee; 
    p ( " \t callee - FUNCTION " + f1.node.name  )
    // p ( " type of callee - " + getNodeType ( f1.node)); 
    var formals = f1.node.params;
    if ( formals != null )
    {
        p ( " \t\t formals - " + formals);
        for ( var i = 0 ; i < formals.length ; i++)
        {
            var t = "" + formals[i];
            p ( " \t\t\t formal : " + t + " actual - " + xc.scope.object[t]);
        }
    }
//    p ( " \t callee - " + xc.callee +  
//        " params - " +  (f1.node.params) + 
//        " args - " + printObject (xc.scope.object.arguments));
    p ( " \t scope - ");
    printScope ( "\t\t", xc.scope );    
    p ( " \t thisObject - " + xc.thisObject);
    p ( " \t result - " + xc.result);
    p ( " \t target - " + xc.target);
    p ( " \t ecmaStrictMode - " + xc.ecmaStrictMode);
    p ( " \t type - " + getXCType(xc.type));
}


var recurs = 0;

var lastSeen = null;

var recurDepth = 0;

function cloneObject ( srcObj )
{
    var newObj = new Object;
    recurs ++; 
    for ( var srcProp in srcObj )
    {
        srcVal = srcObj[srcProp];
        t = typeof srcVal; 
        //p ( " \t \t \t recursion depth - " + recurs + 
        //    " property - " + srcProp + " type - " + t + (t == "string" ? srcVal : ""));
        
        if(t != "function" && t == "object")
        { 
//            p ( " \t \t nested calling ");
            if ( srcVal == null)
                newVal = null;
            else
            {
                //p ( " \t \t \t recursion for property ["+ recurs+"] - " + srcProp + " type - " + t + (t == "string" ? srcVal : ""));
                if ( lastSeen == null || lastSeen != srcVal)
                {
                    lastSeen = srcVal;
                    newVal = cloneObject ( srcVal );
                }

            }
//            p ( " new value = " + newVal);
        }
        else
        {
            newVal = srcVal;
        }
        
        newObj[srcProp] = newVal;
    }
    
    recurs --; 
    return newObj; 
}

var RRIndex = 0 ; 
function ReturnRecord (index, funcName, retValue, pc, actuals)
{
    p ( " creating a new return record with - " + funcName + " " + retValue +  " " + pc );
    this.index = index;
    this.funcName = new String (funcName); 
    this.retValue = retValue; 
    this.pc = new String (pc);     
    this.actuals  = actuals; 
}

function findReturnRecords ( funcName, RRs, actuals)
{
    var matches = new DP_ObCollectionOrdered("index", ReturnRecord); 

    var i = 0; 
    var count = RRs.getCount();
    for ( ; i < count ; i++)
    {
        var mem = RRs.getAt(i);
        if (mem.funcName == funcName && (("" + mem.actuals) == ("" + actuals)))
        {
            matches.add( mem );
            p ( " matching return record #" + mem.index + " \t funcName : " + 
                mem.funcName + " \t returns = " + mem.retValue + 
                " \t pc = " + mem.pc + " \t actuals - " + mem.actuals);
        }
    }
    
    return matches; 
}

function printReturnRecords ( coll )
{
    p ( " printing the return records" );
    var i = 0; 
    var count = coll.getCount();
    for ( ; i < count ; i++)
    {
        var mem = coll.getAt(i);
        p ( " return record #" + mem.index + " \t funcName : " + 
            mem.funcName + " \t returns = " + mem.retValue + 
            " \t pc = " + mem.pc + " \t actuals - " + mem.actuals);
    }
}

var ReturnRecords = new DP_ObCollectionOrdered("index", ReturnRecord); 
var PendingExecutions = new DP_ObCollectionOrdered ("notamper_index", ExecutionContext);

function executeNextPending (xc)
{
    p ( " calling executeNextPending - ");
    if ( ! PendingExecutions.isEmpty() )
    {
        var mem = PendingExecutions.getAt(0);
        PendingExecutions.drop ( mem.notamper_index );
//        p ( " \t now executing - " + mem);
        ExecutionContext.current = mem;
        
        
        p ( " Printing insts to be executed in the pending xc - ");
        var inst = mem.nextInstruction; 
        while ( inst != null)
        {
            p ( " \t inst - " + getNodeType (inst));
            execute ( inst, mem ) ; 
            inst = inst.nextInstruction;
        }
        
    }
}


function printPendingExecutions ( coll )
{
    p ( " Printing the pending executions ");
    var count = coll.getCount (); 
    var i = 0; 
    for ( ; i < count ; i ++)
    {
        var mem = coll.getAt(i);
        p ( " pending# " + i + " next instruct - " + 
            (mem.nextInstruction == null ? " null" : mem.nextInstruction.type));
        //printXC ( mem );
    }
}

// For evaluating ORed/ANDed conditions. 
// basically this data structures enables following symbolic evaluation
// if ( c1 OR c2 OR c3) then x1 else x2; 
// TRUE: c1
// TRUE: NOT c1 AND c2
// TRUE: NOT c1 AND NOT c2 AND c3 
// FALSE: NOT c1 AND NOT c2 AND NOT c3
// and fork the execution of true branch for first three with next instruction
// being the body of the then block and false branch with the rest.    
var conditionIndex = 0;
var conditionCases = new DP_ObCollectionOrdered("index", ConditionRecord); 
function ConditionRecord (index, boolValue, pc)
{
    p ( " Creating a new condition record with - " + index + " value - " + 
        (boolValue ? "T" : "F") +  " pc - " + pc);
    
    this.index = index;
    this.boolValue = boolValue; 
    this.pc = new String (pc);     
    this.processed  = false; 
    this.nextInstruction = null; 
    this.nestingDepth = clauseCounter;
}

function printConditionRecords(CCs)
{
    var i = 0; 
    var count = CCs.getCount();
    p (" ========= current clause level - " + clauseCounter);
    for ( ; i < count ; i++)
    {
        var mem = CCs.getAt(i);
        p ( " Condition Case #" + mem.index + 
            "    depth: " + mem.nestingDepth +
            " val : " + (mem.boolValue ? "T" : "F") + 
            " pro - " + (mem.processed ? "T" : "F") +
            " pc = " + mem.pc); 

    }
}

function isBooleanReturn(id, body)
{   
    var id1 = "" + id; 
     
    if(id1.indexOf("onsubmit_") != -1)
        return true; 
        
    if(id1 == "DOM")
    {
        hasSeenDOM = true; 
        return bRet; 
    }     

    var body = "" + body; 
    if(body.indexOf("type: RETURN") == -1)
    {
        p(" No return instruction in  " + id1);
        return false; 
    }    
    
    return true; 
}

function addRecordIfAbsent (condition, CCs)
{
    if(!isSymbolic(condition))
        return;
        
//    p("\t\t testing if condition is present - " + condition);
    var count = CCs.getCount();
    var i = 0;
    for ( ; i < count ; i++)
    {
        var mem = CCs.getAt(i);
        var str = mem.boolValue + " \t pc = " + mem.pc;
  //      p (" \t\t\t matching against - "  + str);
        if(str.indexOf(condition) != -1)
            return;
    }

    //p("\t\t adding two more conditions - ");
    var falseCondition = " NOT ( " + condition + " ) ";
    conditionCases.add(new ConditionRecord(conditionIndex++, true, condition));
    conditionCases.add(new ConditionRecord(conditionIndex++, false, falseCondition));
}


/************************************************************* notamper end **/

